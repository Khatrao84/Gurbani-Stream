<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gurbani Stream</title>
  
  <link rel="manifest" href="manifest.json">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

  <link rel="preconnect" href="https://www.youtube.com">
  <link rel="preconnect" href="https://www.google.com">
  <link rel="preconnect" href="https://api.rss2json.com">

  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="favicon.png">
  
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gurmukhi:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="https://www.youtube.com/iframe_api"></script>

  <style>
    /* --- CORE STYLES --- */
    html, body {
      margin: 0; padding: 0; height: 100%;
      background-color: black; font-family: "Noto Sans Gurmukhi", sans-serif;
      overflow: hidden; -webkit-tap-highlight-color: transparent; 
      user-select: none; cursor: none;
    }
    body.user-active { cursor: default; }
    
    #container { position: relative; width: 100vw; height: 100vh; }
    
    /* Dedicated Player Container */
    #stream-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; background: black; }
    #yt-player { width: 100%; height: 100%; border: none; }
    
    .video-placeholder { width: 100%; height: 100%; background: black; }
    
    #hls-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; display: none; }
    #audio-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-position: center; background-size: cover; z-index: 1; display: none; }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; cursor: pointer; outline: none; }

    /* --- CHANNEL LIST STYLES --- */
    .channel-list {
      position: absolute; top: 0; width: 320px; height: 100vh; 
      background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
      z-index: 10; display: flex; flex-direction: column; padding: 20px 0;
      box-shadow: 0 0 30px rgba(0,0,0,0.8); opacity: 0; pointer-events: none;
      transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.3s ease;
    }
    #leftList { left: 0; transform: translateX(-100%); border-right: 1px solid rgba(255,255,255,0.1); }
    #rightList { right: 0; transform: translateX(100%); border-left: 1px solid rgba(255,255,255,0.1); }
    .channel-list.open { transform: translateX(0); opacity: 1; pointer-events: auto; }

    .ch-item {
      flex: 1; display: flex; align-items: center; font-size: clamp(14px, 2.2vh, 22px);
      padding: 0 25px; color: rgba(255, 255, 255, 0.7); cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05); font-weight: 500;
      border-left: 5px solid transparent; transition: all 0.1s ease;
    }
    .ch-item.highlighted {
      background-color: #00296B; color: #FFD700; font-weight: bold;
      border-left: 5px solid #FFD700; padding-left: 20px; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); opacity: 1;
    }
    .ch-item.playing::after { content: '●'; margin-left: auto; color: #00ff00; font-size: 14px; }
    .ch-item.ghost { opacity: 0.5; font-style: italic; pointer-events: none; }

    /* --- CHANNEL BANNER --- */
    #channelName {
      position: absolute; bottom: 0; left: 0; width: 100%;
      padding: 31px 20px 10px 20px; font-size: 24px; font-weight: bold;
      text-align: center; z-index: 3; transform: translateY(0); opacity: 0;
      pointer-events: none;
    }
    .style-main { 
        background: linear-gradient(to top, rgba(0, 41, 107, 0.9) 75%, rgba(0,41,107,0.1) 100%);
        color: #FFD700 !important; text-shadow: 2px 2px 4px black;
    }
    .style-alt { 
        background: linear-gradient(to top, rgba(255, 215, 0, 0.9) 75%, rgba(255,215,0,0.1) 100%);
        color: #00296B !important; text-shadow: none;
    }
    #channelName.show { transform: translateY(0); opacity: 1; }
    
    .loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 60px; height: 60px; border: 6px solid rgba(255, 213, 0, 0.2);
      border-radius: 50%; border-top-color: #ffd500;
      animation: spin 1s linear infinite; z-index: 4; display: none;
      pointer-events: none;
    }
    @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
    
    #time-tv {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; z-index: 1; 
      background: url("haarimandr.png") no-repeat center center; background-size: cover; font-family: "Arial Black", sans-serif;
    }
    #time-tv .clock { position: absolute; top: 6%; right: 3%; font-size: 8.7vw; color: #FFD700; text-shadow: 0 0 10px #FFD700; }
    #time-tv .date { position: absolute; top: 2%; right: 3.5%; font-size: 3vw; color: #FFE066; }

    /* --- INSTALL POPUP --- */
    #installBackdrop {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); 
      z-index: 9998; display: none;
    }
    #installHelp {
      position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
      width: 90%; max-width: 600px; text-align: center; color: white;
      font-family: "Arial", sans-serif; pointer-events: none;
    }
    #installHelp h3 { font-size: 22px; margin-bottom: 20px; color: #FFD700; text-transform: uppercase; letter-spacing: 1px; }
    #installHelp p { font-size: 18px; margin: 12px 0; line-height: 1.5; color: #f0f0f0; }

    #installPopup {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: #00296B; border: 2px solid #FFD700; border-radius: 12px;
      padding: 20px 25px; z-index: 9999; display: none; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.9);
      color: white; font-family: sans-serif; text-align: center;
      width: 80%; max-width: 320px;
    }
    #installPopup p { margin: 0 0 15px 0; font-size: 18px; line-height: 1.4; }
    #installPopup button {
      background: #FFD700; color: #00296B; border: none; padding: 12px 25px;
      font-weight: bold; border-radius: 6px; cursor: pointer; font-size: 16px; width: 100%;
    }
    #installPopup .close-btn { position: absolute; top: 8px; right: 12px; color: #ccc; font-size: 20px; cursor: pointer; }
  </style>
</head>
<body>
  <div id="container">
    <div id="leftList" class="channel-list"></div>
    <div id="rightList" class="channel-list"></div>

    <div id="stream-container"><div id="yt-player"></div></div>
    
    <video id="hls-video" playsinline></video>
    <audio id="bg-audio" preload="auto"></audio>
    <div id="audio-bg"></div>
    <div id="time-tv"><div class="clock"></div><div class="date"></div></div>
    
    <div id="installBackdrop">
      <div id="installHelp">
        <h3>CONTROLS</h3>
        <p>1. Single Click for Channel forward.</p>
        <p>2. Swipe in any direction for Channel backward.</p>
        <p>3. Long Press for toggle ( Channel 0-3 ).</p>
        <p>4. Green Button: Refresh App.</p>
        <p>5. Red Button: Switch Stream (Toggle).</p>
        <p>6. Yellow Button: Toggle Loop / Restart (Ch 0).</p>
        <p>7. Blue Button: Channel List.</p>
      </div>
    </div>
    
    <div id="installPopup">
      <div class="close-btn" onclick="InstallService.closePopup()">✕</div>
      <p id="installText">Install Gurbani Stream App?</p>
      <button id="installActionBtn">Install Now</button>
    </div>

    <div id="overlay" tabindex="0"></div>
    <div id="channelName" class="style-main"></div>
    <div class="loading" id="loading"></div>
  </div>

<script>
const Config = {
  SCROLL_SPEED_MS: 350,
  AUTO_REFRESH_MS: 10800000, 
  LOAD_TIMEOUT_MS: 12000,
  RSS_FETCH_TIMEOUT: 4000,
  KEY_THROTTLE_MS: 300,
  LOCAL_AUDIO_FILE: "sukhmani.mp3",
  LOCAL_RADIO_IMG: "audioharimandar.png",
  LONG_PRESS_MS: 800,
  SWIPE_THRESHOLD: 50,
  LIST_TIMEOUT_MS: 8000,
  RSS_CACHE_TIME: 60000 // 1 Minute Cache for RSS
};

const CHANNELS = [
  { name: "0. ਸੁਖਮਨੀ ਸਾਹਿਬ", type: "time", allowToggle: true },
  { name: "1. ਸ਼੍ਰੀ ਪਟਨਾ ਸਾਹਿਬ ਲਾਈਵ", channelId: "UC3nqw1kd4AK1q9e68YUoLDQ", fallback: "TTK7eNuI3M0", type: "direct", allowToggle: true },
  { name: "2. ਸ਼੍ਰੀ ਅੰਮ੍ਰਿਤਸਰ ਸਾਹਿਬ ਲਾਈਵ", channelId: "UCYn6UEtQ771a_OWSiNBoG8w", type: "direct-rss", allowToggle: true, isRadioHybrid: true, radioUrl: "https://live.sgpc.net:8443/;", radioImage: Config.LOCAL_RADIO_IMG },
  { name: "3. ਸ਼੍ਰੀ ਫਤੇਹਗੜ੍ਹ ਸਾਹਿਬ ਲਾਈਵ", channelId: "UCudVHqnOekwcvpzNpY8_ERw", type: "direct-rss", allowToggle: true },
  { name: "4. ਸ਼੍ਰੀ ਕੋਤਵਾਲੀ ਸਾਹਿਬ ਮੋਰਿੰਡਾ ਲਾਈਵ", channelId: "UCri5TwOgoDY3ywUDK9Ar1Lg", type: "direct" },
  { name: "5. ਸ਼੍ਰੀ ਆਨੰਦਪੁਰ ਸਾਹਿਬ ਲਾਈਵ", channelId: "UCSx5035_us8h8DOp_YhQDaw", type: "direct" },
  { name: "6. ਸ਼੍ਰੀ ਦਮਦਮਾ ਸਾਹਿਬ ਲਾਈਵ", channelId: "UCY8jMpyRRcdzSf6uLiU6izQ", type: "direct" },
  { name: "7. ਸ਼੍ਰੀ ਦੂਖ-ਨਿਵਾਰਨ ਸਾਹਿਬ ਲੁਧਿਆਣਾ ਲਾਈਵ", channelId: "UCPKPN4bzM8Ja-F_kIEZoAhA", type: "direct-rss" },
  { name: "8. ਸ਼੍ਰੀ ਦੂਖ-ਨਿਵਾਰਨ ਸਾਹਿਬ ਪਟਿਆਲਾ ਲਾਈਵ", channelId: "UC7Uf4ZOlCGM3zBCLqcNPtJg", type: "direct-rss" },
  { name: "9. ਸ਼੍ਰੀ ਬਾਬਾ ਦੀਪ ਸਿੰਘ ਜੀ ਅੰਮ੍ਰਿਤਸਰ ਲਾਈਵ", channelId: "UCxWx-MPft_7mKrFtN6uOaAA", type: "direct" },
  { name: "10. ਸ਼੍ਰੀ ਪੰਜੋਖਰਾ ਸਾਹਿਬ ਅੰਬਾਲਾ ਲਾਈਵ", channelId: "UCWd5TUzbLUe6_TWKW9vaDmQ", type: "direct" },
  { name: "11. ਸ਼੍ਰੀ ਬੰਗਲਾ ਸਾਹਿਬ ਦਿੱਲੀ ਲਾਈਵ", channelId: "UCA1Jqo-WXVuMgs4WcD5f5Yw", type: "auto-rss" },
  { name: "12. ਸ਼੍ਰੀ ਸੀਸ ਗੰਜ ਸਾਹਿਬ ਦਿੱਲੀ ਲਾਈਵ", channelId: "UCm0p8BmL4d914gBefceFxxA", type: "direct" },
  { name: "13. ਸ਼੍ਰੀ ਸਿੰਘ ਸ਼ਹੀਦਾਂ ਸਾਹਿਬ ਸੋਹਾਣਾ ਲਾਈਵ", channelId: "UCflFRcHHT8Ab7AvjvIVcrQA", type: "direct" },
  { name: "14. ਸ਼੍ਰੀ ਹਜ਼ੂਰ ਸਾਹਿਬ ਲਾਈਵ", channelId: "UCuerQ47I9Y2qxr4eIopxbYw", type: "direct" }
];

function getInitialChannel() {
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  if (isMobile) return 0;
  const saved = parseInt(localStorage.getItem('currentChannel'));
  return isNaN(saved) ? 0 : saved;
}

const AppState = {
  currentChannel: getInitialChannel(),
  streamToggle: 0,
  activeLoadId: 0, 
  lastScrollTime: Date.now() + 2000, 
  timers: { load: null, banner: null, watchdog: null, refresh: null, list: null, doctor: null },
  suppressClick: false,
  isListOpen: false,
  virtualIndex: 0
};

const UI = {
  container: document.getElementById('container'),
  streamContainer: document.getElementById('stream-container'),
  hlsVideo: document.getElementById('hls-video'),
  timeTv: document.getElementById('time-tv'),
  audioBg: document.getElementById('audio-bg'),
  channelName: document.getElementById('channelName'),
  loading: document.getElementById('loading'),
  overlay: document.getElementById('overlay'),
  bgAudio: document.getElementById('bg-audio'),
  clock: document.querySelector('#time-tv .clock'),
  date: document.querySelector('#time-tv .date'),
  leftList: document.getElementById('leftList'),
  rightList: document.getElementById('rightList'),
  installPopup: document.getElementById('installPopup'),
  installBackdrop: document.getElementById('installBackdrop'),
  installText: document.getElementById('installText'),
  installBtn: document.getElementById('installActionBtn')
};

const InstallService = {
  deferredPrompt: null,
  init() {
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) return; 
    window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); this.deferredPrompt = e; this.showAndroidPopup(); });
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) this.showIOSPopup();
  },
  showAndroidPopup() {
    UI.installBackdrop.style.display = 'block'; UI.installPopup.style.display = 'block';
    UI.installText.textContent = "Install Gurbani Stream App?";
    UI.installBtn.textContent = "Install Now";
    UI.installBtn.onclick = () => { if (this.deferredPrompt) { this.deferredPrompt.prompt(); this.deferredPrompt.userChoice.then((r) => { if (r.outcome === 'accepted') this.closePopup(); this.deferredPrompt = null; }); } };
  },
  showIOSPopup() {
    UI.installBackdrop.style.display = 'block'; UI.installPopup.style.display = 'block';
    UI.installText.innerHTML = "To install: Tap Share <br> then 'Add to Home Screen'";
    UI.installBtn.style.display = 'none'; setTimeout(() => this.closePopup(), 8000);
  },
  closePopup() { UI.installPopup.style.display = 'none'; UI.installBackdrop.style.display = 'none'; }
};

const SystemService = {
  wakeLock: null,
  async requestWakeLock() { if ('wakeLock' in navigator) try { this.wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} },
  enableFullscreenAndOrientation() {
    if (!document.fullscreenElement) { if (UI.container.requestFullscreen) UI.container.requestFullscreen().catch(e=>{}); else if (UI.container.webkitRequestFullscreen) UI.container.webkitRequestFullscreen(); }
    if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(e=>{});
  },
  init() {
    this.requestWakeLock();
    document.addEventListener('visibilitychange', async () => { if (this.wakeLock !== null && document.visibilityState === 'visible') await this.requestWakeLock(); });
    const userInteract = () => { this.enableFullscreenAndOrientation(); this.requestWakeLock(); window.removeEventListener('click', userInteract); window.removeEventListener('touchstart', userInteract); };
    window.addEventListener('click', userInteract); window.addEventListener('touchstart', userInteract);
  }
};

const DataService = {
  rssCache: {},
  async fetchRSS(channelId, force = false) {
    const now = Date.now();
    if (!force && this.rssCache[channelId] && (now - this.rssCache[channelId].time < Config.RSS_CACHE_TIME)) {
      return this.rssCache[channelId].vid;
    }
    
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), Config.RSS_FETCH_TIMEOUT);
    try {
      const url = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent('https://www.youtube.com/feeds/videos.xml?channel_id=' + channelId)}&t=${now}`;
      const res = await fetch(url, { signal: controller.signal });
      clearTimeout(timeout);
      if (!res.ok) throw new Error("RSS Error");
      const data = await res.json();
      const vidId = (data.items && data.items.length > 0) ? data.items[0].link.split('v=')[1] : null;
      
      this.rssCache[channelId] = { vid: vidId, time: now };
      return vidId;
    } catch (e) { return null; }
  }
};

const PlayerService = {
  player: null,
  isReady: false,
  currentVideoId: null,
  containerId: 'yt-player',

  init() {
    // Initialize ONE player instance and keep it alive
    window.onYouTubeIframeAPIReady = () => {
      this.player = new YT.Player(this.containerId, {
        height: '100%', width: '100%',
        playerVars: { 
          'autoplay': 1, 'mute': 1, 'controls': 0, 'rel': 0, 
          'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0, 'playsinline': 1 
        },
        events: {
          'onReady': (e) => { this.isReady = true; e.target.mute(); },
          'onStateChange': (e) => this.onStateChange(e),
          'onError': (e) => this.onError(e)
        }
      });
    };
    if (window.YT && window.YT.Player) window.onYouTubeIframeAPIReady();
  },

  // Robust Load Function: Prefers Update over Re-creation
  async load(channel, toggle, loadId) {
    // 1. Reset UI
    UI.loading.style.display = 'block';
    
    // 2. Determine Strategy: Video ID vs Channel Live Embed
    let targetVideoId = null;
    let isFallback = false;

    // Try to resolve a specific VIDEO ID first (Most robust "Netflix" method)
    if (channel.type === 'time') return; // Handled in App
    
    // Check toggle/fallback specifics
    if (toggle === 1 && channel.fallback) {
        targetVideoId = channel.fallback;
    } 
    else if (channel.isRadioHybrid && toggle === 1) {
        // Radio handled in App, just ensure player is hidden
        this.stop(); return; 
    }
    else {
        // Main Logic: Try to get Live ID via RSS for ALL live channels if possible
        // This makes transitions smoother than reloading iframe for channel_live
        const fetchedId = await DataService.fetchRSS(channel.channelId);
        if (fetchedId) {
            targetVideoId = fetchedId;
        } else {
            // If RSS fails, we might have to use fallback or legacy embed
            if (channel.fallback) isFallback = true;
        }
    }

    if (loadId !== AppState.activeLoadId) return;

    // 3. Execute Load
    UI.streamContainer.style.display = 'block';
    
    if (targetVideoId) {
        this.playVideoId(targetVideoId);
    } else {
        // Absolute fallback: If no ID found and RSS failed, use Iframe replacement (Legacy method)
        // Only do this if we really have to, as it causes black flash
        this.forceLegacyEmbed(channel.channelId);
    }
  },

  playVideoId(vidId) {
    if (this.currentVideoId === vidId && this.player && this.player.getPlayerState() === YT.PlayerState.PLAYING) {
        UI.loading.style.display = 'none'; return;
    }
    this.currentVideoId = vidId;

    if (this.isReady && this.player && typeof this.player.loadVideoById === 'function') {
        try {
            this.player.loadVideoById({videoId: vidId});
        } catch(e) { this.forceReinit(vidId); }
    } else {
        // Player died or not ready, re-init
        this.forceReinit(vidId);
    }
  },

  forceLegacyEmbed(channelId) {
    // This destroys the smooth player and puts a raw iframe. 
    // Used only when we cannot find a video ID.
    this.isReady = false; 
    const embedUrl = `https://www.youtube.com/embed/live_stream?channel=${channelId}&autoplay=1&mute=1&controls=0&enablejsapi=1&origin=${window.location.origin}`;
    const iframe = document.createElement('iframe');
    iframe.id = this.containerId; iframe.src = embedUrl; 
    iframe.style.width = "100%"; iframe.style.height = "100%"; iframe.style.border = "none";
    
    const old = document.getElementById(this.containerId);
    if (old) old.replaceWith(iframe);
    
    // We lose the API handle here effectively, but we try to re-bind
    this.player = new YT.Player(this.containerId, {
        events: {
             'onReady': (e) => { this.isReady = true; e.target.playVideo(); },
             'onStateChange': (e) => this.onStateChange(e),
             'onError': (e) => this.onError(e)
        }
    });
  },

  forceReinit(vidId) {
    const old = document.getElementById(this.containerId);
    const newDiv = document.createElement('div'); newDiv.id = this.containerId;
    if (old) old.replaceWith(newDiv);
    
    this.player = new YT.Player(this.containerId, {
        height: '100%', width: '100%', videoId: vidId,
        playerVars: { 'autoplay': 1, 'mute': 1, 'controls': 0, 'rel': 0, 'modestbranding': 1, 'iv_load_policy': 3 },
        events: {
            'onReady': (e) => { this.isReady = true; e.target.playVideo(); },
            'onStateChange': (e) => this.onStateChange(e),
            'onError': (e) => this.onError(e)
        }
    });
  },

  stop() {
    if (this.player && typeof this.player.stopVideo === 'function') try { this.player.stopVideo(); } catch(e){}
    UI.streamContainer.style.display = 'none';
  },

  onStateChange(e) {
    if (e.data === YT.PlayerState.PLAYING) {
        UI.loading.style.display = 'none';
        try { e.target.unMute(); } catch(err){}
        // Ensure background audio is killed
        UI.bgAudio.pause(); 
    } 
    else if (e.data === YT.PlayerState.BUFFERING) {
        UI.loading.style.display = 'block';
        // Stream Doctor: If buffering > 10s, reload
        clearTimeout(AppState.timers.doctor);
        AppState.timers.doctor = setTimeout(() => {
            if (AppState.activeLoadId > 0 && this.player.getPlayerState() === YT.PlayerState.BUFFERING) {
                console.log("Stream Doctor: Stuck buffering, reloading...");
                const cur = AppState.currentChannel;
                // Force reload of same channel
                App.loadChannel(cur, AppState.streamToggle);
            }
        }, 10000);
    }
  },

  onError(e) {
    console.warn("Player Error:", e.data);
    // Auto-Recovery Logic
    if (AppState.activeLoadId > 0) {
        const cur = AppState.currentChannel;
        // If error 150 (embed restricted) or 100, try toggle/fallback
        if (e.data === 150 || e.data === 100 || e.data === 101) {
             // If we aren't already on fallback, try fallback
             if (AppState.streamToggle === 0) {
                 App.triggerChannelLoad(cur); // This might toggle logic if configured, or just reload
             }
        }
    }
  }
};

const App = {
  init() {
    AppState.activeLoadId++;
    SystemService.init();
    InstallService.init(); 
    PlayerService.init(); // Initialize Singleton Player
    
    AppState.virtualIndex = AppState.currentChannel;
    this.renderLists();
    
    // Initial Load
    this.loadChannel(AppState.currentChannel, 0);
    this.setupInputs();
    this.setupClock();
    AppState.timers.refresh = setTimeout(() => window.location.reload(), Config.AUTO_REFRESH_MS);
  },

  // --- LIST LOGIC (UNCHANGED) ---
  renderLists() {
    UI.leftList.innerHTML = ''; UI.rightList.innerHTML = '';
    for (let i = 0; i <= 7; i++) UI.leftList.appendChild(this.createListItem(CHANNELS[i].name, i));
    for (let i = 8; i <= 14; i++) UI.rightList.appendChild(this.createListItem(CHANNELS[i].name, i));
    const ghost = document.createElement('div'); ghost.className = 'ch-item ghost'; ghost.textContent = CHANNELS[0].name; UI.rightList.appendChild(ghost);
  },
  createListItem(name, index) {
      const el = document.createElement('div'); el.className = 'ch-item'; el.textContent = name; el.dataset.index = index;
      el.onclick = (e) => { e.stopPropagation(); AppState.virtualIndex = index; this.confirmSelection(); };
      return el;
  },
  getRealIndex(vIndex) { return (vIndex === 15) ? 0 : vIndex; },
  updateListVisuals() {
     document.querySelectorAll('.ch-item:not(.ghost)').forEach(el => {
         const idx = parseInt(el.dataset.index); el.classList.remove('highlighted'); el.classList.remove('playing');
         if (idx === AppState.virtualIndex) el.classList.add('highlighted');
         if (idx === AppState.currentChannel) el.classList.add('playing');
     });
  },
  toggleList() {
     if (AppState.isListOpen) { this.confirmSelection(); } 
     else {
        AppState.isListOpen = true;
        if (!(AppState.currentChannel === 0 && AppState.virtualIndex === 15)) AppState.virtualIndex = AppState.currentChannel;
        this.showCorrectList(); this.updateListVisuals(); this.resetListTimer();
     }
  },
  showCorrectList() {
      if (AppState.virtualIndex <= 7) { UI.leftList.classList.add('open'); UI.rightList.classList.remove('open'); } 
      else { UI.rightList.classList.add('open'); UI.leftList.classList.remove('open'); }
  },
  navigateList(dir) {
     let next = AppState.virtualIndex + dir;
     if (AppState.virtualIndex === 14 && dir === 1) next = 0; else if (AppState.virtualIndex === 0 && dir === -1) next = 14;
     if (next > 14) next = 0; if (next < 0) next = 14;
     AppState.virtualIndex = next; this.showCorrectList(); this.updateListVisuals(); this.resetListTimer(); 
  },
  resetListTimer() {
     clearTimeout(AppState.timers.list); AppState.timers.list = setTimeout(() => { if (AppState.isListOpen) this.confirmSelection(); }, Config.LIST_TIMEOUT_MS);
  },
  confirmSelection() {
     AppState.isListOpen = false; UI.leftList.classList.remove('open'); UI.rightList.classList.remove('open'); clearTimeout(AppState.timers.list);
     const target = this.getRealIndex(AppState.virtualIndex); if (target !== AppState.currentChannel) this.triggerChannelLoad(target);
  },
  // ----------------------------

  setupClock() {
    setInterval(() => {
      const now = new Date();
      UI.clock.textContent = now.toLocaleTimeString('en-US', { hour12: true });
      UI.date.textContent = now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
    }, 1000);
  },
  setupInputs() {
    let cursorTimeout;
    const wakeUI = () => { document.body.classList.add('user-active'); clearTimeout(cursorTimeout); cursorTimeout = setTimeout(() => document.body.classList.remove('user-active'), 3000); };
    window.addEventListener('mousemove', wakeUI); window.addEventListener('click', wakeUI);
    
    window.addEventListener('wheel', (e) => {
        if (AppState.isListOpen || Math.abs(e.deltaY) < 10) return; 
        const now = Date.now(); if (now - AppState.lastScrollTime < Config.KEY_THROTTLE_MS) return; 
        AppState.lastScrollTime = now; this.changeChannel(-1);
    });
    window.addEventListener('mousedown', (e) => { if (e.button === 1) { e.preventDefault(); this.triggerChannelLoad(AppState.currentChannel); } });

    let touchStartX = 0, touchStartY = 0, pressTimer = null;
    UI.overlay.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) return; touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; AppState.suppressClick = false; 
        pressTimer = setTimeout(() => { AppState.suppressClick = true; this.triggerChannelLoad(AppState.currentChannel); if (navigator.vibrate) navigator.vibrate(50); }, Config.LONG_PRESS_MS);
    }, {passive: true});
    UI.overlay.addEventListener('touchmove', (e) => { if (Math.abs(e.touches[0].clientX - touchStartX) > 10 || Math.abs(e.touches[0].clientY - touchStartY) > 10) clearTimeout(pressTimer); }, {passive: true});
    UI.overlay.addEventListener('touchend', (e) => {
        clearTimeout(pressTimer); if (AppState.suppressClick) return; 
        if (Math.abs(e.changedTouches[0].clientX - touchStartX) > Config.SWIPE_THRESHOLD || Math.abs(e.changedTouches[0].clientY - touchStartY) > Config.SWIPE_THRESHOLD) { AppState.suppressClick = true; this.changeChannel(-1); }
    });
    UI.overlay.addEventListener('click', (e) => {
        if (AppState.isListOpen) { this.toggleList(); return; }
        if (AppState.suppressClick) { AppState.suppressClick = false; e.stopImmediatePropagation(); return; }
        this.changeChannel(1); 
    });

    let keyBuffer = "", bufferTimer = null;
    window.addEventListener('keydown', (e) => {
      const k = e.key, c = e.keyCode, now = Date.now();
      
      if (k === 'ColorF1Green' || c === 404 || k === 'Green') { e.preventDefault(); window.location.reload(); return; }
      if (k === 'ColorF0Red' || c === 403 || k === 'Red') { e.preventDefault(); (AppState.currentChannel === 0) ? this.toggleCh0Audio() : this.triggerChannelLoad(AppState.currentChannel); return; }
      if (k === 'ColorF2Yellow' || c === 405 || k === 'Yellow') {
         e.preventDefault();
         if (AppState.currentChannel === 0) {
            if (UI.bgAudio.paused) { UI.bgAudio.currentTime = 0; UI.bgAudio.play().then(() => this.showBanner("Restarting Audio...", 1)); } 
            else { UI.bgAudio.loop = !UI.bgAudio.loop; this.showBanner(UI.bgAudio.loop ? "Loop Mode: ON" : "Loop Mode: OFF", UI.bgAudio.loop ? 1 : 0); }
         } else this.showBanner("Available on Ch 0 Only", 0);
         return;
      }
      if (k === 'ColorF3Blue' || c === 406 || k === 'Blue') { e.preventDefault(); this.toggleList(); return; }

      if (!/^[0-9]$/.test(k)) { if (now - AppState.lastScrollTime < Config.KEY_THROTTLE_MS) return; AppState.lastScrollTime = now; }
      wakeUI();

      const isUp = (k === "ArrowRight" || k === "ArrowUp" || k === "ChannelUp" || c === 427 || k === "PageUp");
      const isDown = (k === "ArrowLeft" || k === "ArrowDown" || k === "ChannelDown" || c === 428 || k === "PageDown");

      if (isUp || isDown) { e.preventDefault(); AppState.isListOpen ? this.navigateList(isUp ? -1 : 1) : this.changeChannel(isUp ? 1 : -1); return; }

      if (/^[0-9]$/.test(k)) {
        e.preventDefault(); keyBuffer += k; clearTimeout(bufferTimer);
        bufferTimer = setTimeout(() => {
            const num = parseInt(keyBuffer, 10); keyBuffer = "";
            let targetIndex = (num === 0) ? CHANNELS.findIndex(ch => ch.name.startsWith("0.")) : CHANNELS.findIndex(ch => ch.name.startsWith(num + "."));
            if (targetIndex !== -1) { AppState.isListOpen ? (AppState.virtualIndex = targetIndex, this.showCorrectList(), this.updateListVisuals(), this.resetListTimer()) : this.triggerChannelLoad(targetIndex); }
        }, 1200); 
      }
    });
  },
  changeChannel(dir) {
    const newIdx = (AppState.currentChannel + dir + CHANNELS.length) % CHANNELS.length;
    this.triggerChannelLoad(newIdx);
  },
  triggerChannelLoad(index) {
    const isSame = (AppState.currentChannel === index); const channel = CHANNELS[index];
    if (isSame && channel.type === 'time') { this.toggleCh0Audio(); return; }
    if (isSame && channel.allowToggle) AppState.streamToggle = (AppState.streamToggle === 0) ? 1 : 0; else AppState.streamToggle = 0;
    
    AppState.currentChannel = index; AppState.virtualIndex = index;
    this.showBanner(channel.name, AppState.streamToggle);
    
    clearTimeout(AppState.timers.load); AppState.activeLoadId++; const thisId = AppState.activeLoadId;
    AppState.timers.load = setTimeout(() => { if (thisId === AppState.activeLoadId) this.loadChannel(index, AppState.streamToggle); }, Config.SCROLL_SPEED_MS);
  },
  toggleCh0Audio() {
    if (UI.bgAudio.paused) { UI.bgAudio.play().then(() => this.showBanner("0. ਸੁਖਮਨੀ ਸਾਹਿਬ (Playing)", 1)); }
    else { UI.bgAudio.pause(); this.showBanner("0. ਸੁਖਮਨੀ ਸਾਹਿਬ (Paused)", 0); }
  },
  showBanner(name, mode) {
    UI.channelName.textContent = name; UI.channelName.className = (mode === 1) ? 'style-alt show' : 'style-main show';
    clearTimeout(AppState.timers.banner); AppState.timers.banner = setTimeout(() => UI.channelName.classList.remove("show"), 3000);
  },
  loadChannel(index, toggle) {
    const channel = CHANNELS[index]; const genId = AppState.activeLoadId;
    localStorage.setItem('currentChannel', index); 
    
    // UI Cleanup (except player)
    UI.audioBg.style.display = 'none'; UI.timeTv.style.display = 'none';
    clearTimeout(AppState.timers.watchdog);
    
    // Safety watchdog: if nothing happens in 12s, kill spinner
    AppState.timers.watchdog = setTimeout(() => { if (genId === AppState.activeLoadId) UI.loading.style.display = 'none'; }, Config.LOAD_TIMEOUT_MS);

    // Channel 0: Audio Mode
    if (channel.type === 'time') {
      PlayerService.stop(); // Stop video player
      UI.loading.style.display = 'none'; UI.timeTv.style.display = 'block'; 
      UI.bgAudio.src = Config.LOCAL_AUDIO_FILE; UI.bgAudio.currentTime = 0; UI.bgAudio.volume = 1.0; 
      this.showBanner(channel.name + " (Stopped)", 0); 
      return;
    }

    // Hybrid Radio (Audio only)
    if (channel.isRadioHybrid && toggle === 1) {
      PlayerService.stop();
      UI.audioBg.style.backgroundImage = `url('${channel.radioImage}')`; UI.audioBg.style.display = 'block'; UI.loading.style.display = 'none'; 
      UI.bgAudio.src = channel.radioUrl; UI.bgAudio.play().catch(e => console.warn(e)); 
      this.showBanner(channel.name, 1); 
      return;
    }

    // Video Mode: Hand off to Robust PlayerService
    PlayerService.load(channel, toggle, genId);
  }
};
App.init(); 
</script>
</body>
</html>
